//! # Tool System (orientation)
//!
//! Tools extend an agent with well-described capabilities. Conceptually, a tool
//! declares identity (name/description), an input schema, and an `execute`
//! entrypoint. Agents present available tools to the model, and the runner
//! routes tool-calls through the Tower stack (policy layers) to the base tool.
//!
//! This module provides the `Tool` trait, plus `FunctionTool` (untyped) and
//! `TypedFunctionTool` (strongly-typed). Policy composition and execution flow
//! are described at a high level in `service.rs` and the README. Implementation
//! details are intentionally omitted here to keep comments focused on orientation.

use async_trait::async_trait;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::fmt::Debug;
use std::marker::PhantomData;
use std::sync::Arc;

use crate::error::Result;
use crate::service::ErasedToolLayer;

/// Represents the result of a tool's execution.
///
/// A `ToolResult` encapsulates the output of a tool, along with metadata
/// indicating whether the result is final and any errors that occurred. This
/// allows the agent to process the tool's output and decide on the next steps.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolResult {
    /// The output generated by the tool, represented as a [`serde_json::Value`].
    /// This allows for structured data to be returned from tools.
    pub output: Value,
    /// A flag indicating whether this result should be considered the final
    /// output of the agent's run. If `true`, the agent will stop execution
    /// and return this output.
    pub is_final: bool,
    /// An optional error message that provides details if the tool execution
    /// failed. If `None`, the tool executed successfully.
    pub error: Option<String>,
}

impl ToolResult {
    /// Creates a successful tool result with the given output.
    pub fn success(output: Value) -> Self {
        Self {
            output,
            is_final: false,
            error: None,
        }
    }

    /// Creates a final output result.
    pub fn final_output(output: Value) -> Self {
        Self {
            output,
            is_final: true,
            error: None,
        }
    }

    /// Creates an error result with a descriptive message.
    pub fn error(message: String) -> Self {
        Self {
            output: Value::Null,
            is_final: false,
            error: Some(message),
        }
    }
}

// NOTE: ToolCall definition removed; use crate::items::ToolCall

/// A tool with attached layers.
///
/// This wrapper allows tools to carry their own layers, which will be applied
/// when the tool is executed. This enables tools to be self-contained and
/// manage their own cross-cutting concerns.
pub struct LayeredTool {
    tool: Arc<dyn Tool>,
    layers: Vec<Arc<dyn ErasedToolLayer>>,
}

impl LayeredTool {
    /// Create a new layered tool from a base tool.
    pub fn new(tool: Arc<dyn Tool>) -> Self {
        Self {
            tool,
            layers: Vec::new(),
        }
    }

    /// Add a layer to this tool.
    ///
    /// Layers are applied in the order they are added, wrapping from outside-in
    /// following Tower's pattern.
    pub fn layer(mut self, layer: Arc<dyn ErasedToolLayer>) -> Self {
        self.layers.push(layer);
        self
    }

    /// Get the underlying tool.
    pub fn inner(&self) -> &Arc<dyn Tool> {
        &self.tool
    }

    /// Get the layers attached to this tool.
    pub fn layers(&self) -> &[Arc<dyn ErasedToolLayer>] {
        &self.layers
    }
}

impl Debug for LayeredTool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("LayeredTool")
            .field("tool", &self.tool.name())
            .field("layers_count", &self.layers.len())
            .finish()
    }
}

#[async_trait]
impl Tool for LayeredTool {
    fn name(&self) -> &str {
        self.tool.name()
    }

    fn description(&self) -> &str {
        self.tool.description()
    }

    fn parameters_schema(&self) -> Value {
        self.tool.parameters_schema()
    }

    async fn execute(&self, arguments: Value) -> Result<ToolResult> {
        // For now, just delegate to the inner tool
        // The layers will be applied by the runner when it builds the service stack
        self.tool.execute(arguments).await
    }

    fn requires_approval(&self) -> bool {
        self.tool.requires_approval()
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

/// Defines the interface for all tools that can be used by an agent.
///
/// The `Tool` trait provides a common structure for defining external
/// capabilities that an agent can leverage. Implementors of this trait must
/// provide a name, a description, a parameter schema, and the execution logic.
#[async_trait]
pub trait Tool: Send + Sync + Debug {
    /// Unique identifier for the tool.
    fn name(&self) -> &str;

    /// Human-readable description of the tool's purpose.
    fn description(&self) -> &str;

    /// JSON schema describing expected arguments.
    fn parameters_schema(&self) -> Value;

    /// Execute with the provided arguments.
    async fn execute(&self, arguments: Value) -> Result<ToolResult>;

    /// Indicates whether the tool requires approval before execution.
    fn requires_approval(&self) -> bool {
        false
    }

    /// Enable downcasting to concrete types.
    fn as_any(&self) -> &dyn std::any::Any {
        // Default implementation returns a dummy value
        // Concrete types should override this
        &()
    }
}

/// A concrete `Tool` that wraps a Rust function.
#[derive(Clone)]
pub struct FunctionTool {
    name: String,
    description: String,
    parameters_schema: Value,
    function: Arc<dyn Fn(Value) -> Result<Value> + Send + Sync>,
}

impl std::fmt::Debug for FunctionTool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FunctionTool")
            .field("name", &self.name)
            .field("description", &self.description)
            .field("parameters_schema", &self.parameters_schema)
            .finish()
    }
}

impl Default for FunctionTool {
    /// Creates a default FunctionTool with example configuration.
    ///
    /// This is primarily for demonstration - real tools should be constructed
    /// with specific functionality.
    fn default() -> Self {
        Self::simple("example", "An example tool", |input: String| {
            format!("Processed: {}", input)
        })
    }
}

impl FunctionTool {
    /// Create a `FunctionTool` with a custom schema and function.
    pub fn new<F>(name: String, description: String, parameters_schema: Value, function: F) -> Self
    where
        F: Fn(Value) -> Result<Value> + Send + Sync + 'static,
    {
        Self {
            name,
            description,
            parameters_schema,
            function: Arc::new(function),
        }
    }

    /// Convenience for a single `String` input, returning a `String`.
    pub fn simple<F>(name: &str, description: &str, function: F) -> Self
    where
        F: Fn(String) -> String + Send + Sync + 'static,
    {
        let name = name.to_string();
        let wrapped = move |args: Value| {
            let input = args
                .get("input")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let output = function(input);
            Ok(Value::String(output))
        };

        Self {
            name: name.clone(),
            description: description.to_string(),
            parameters_schema: serde_json::json!({
                "type": "object",
                "properties": {"input": {"type": "string", "description": "Input"}},
                "required": ["input"]
            }),
            function: Arc::new(wrapped),
        }
    }

    /// Set a custom name for this tool.
    ///
    /// By default, tools use the name provided at construction.
    /// This method allows overriding that name.
    pub fn with_name(mut self, name: impl Into<String>) -> Self {
        self.name = name.into();
        self
    }

    /// Add a layer to this tool, returning a LayeredTool.
    ///
    /// This consumes the tool and returns a LayeredTool that can have
    /// additional layers added to it.
    pub fn layer(self, layer: Arc<dyn ErasedToolLayer>) -> LayeredTool {
        LayeredTool::new(Arc::new(self)).layer(layer)
    }
}

#[async_trait]
impl Tool for FunctionTool {
    fn name(&self) -> &str {
        &self.name
    }

    fn description(&self) -> &str {
        &self.description
    }

    fn parameters_schema(&self) -> Value {
        self.parameters_schema.clone()
    }

    async fn execute(&self, arguments: Value) -> Result<ToolResult> {
        let func = self.function.clone();
        let args = arguments;
        let join = tokio::task::spawn_blocking(move || (func)(args)).await;
        match join {
            Ok(res) => match res {
                Ok(output) => Ok(ToolResult::success(output)),
                Err(e) => Ok(ToolResult::error(e.to_string())),
            },
            Err(e) => Ok(ToolResult::error(format!(
                "tool panicked or was cancelled: {}",
                e
            ))),
        }
    }
}

/// A typed function tool that (de)serializes inputs/outputs via serde.
pub struct TypedFunctionTool<I, O, F>
where
    I: serde::de::DeserializeOwned + Send + 'static,
    O: serde::Serialize + Send + 'static,
    F: Fn(I) -> crate::error::Result<O> + Send + Sync + 'static,
{
    name: String,
    description: String,
    schema: Value,
    function: Arc<F>,
    _in: PhantomData<I>,
    _out: PhantomData<O>,
}

impl<I, O, F> std::fmt::Debug for TypedFunctionTool<I, O, F>
where
    I: serde::de::DeserializeOwned + Send + 'static,
    O: serde::Serialize + Send + 'static,
    F: Fn(I) -> crate::error::Result<O> + Send + Sync + 'static,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TypedFunctionTool")
            .field("name", &self.name)
            .field("description", &self.description)
            .field("schema", &self.schema)
            .finish()
    }
}

impl<I, O, F> TypedFunctionTool<I, O, F>
where
    I: serde::de::DeserializeOwned + Send + Sync + 'static,
    O: serde::Serialize + Send + Sync + 'static,
    F: Fn(I) -> crate::error::Result<O> + Send + Sync + 'static,
{
    /// Create a new typed tool with an explicit JSON schema for the input type.
    pub fn new(
        name: impl Into<String>,
        description: impl Into<String>,
        schema: Value,
        f: F,
    ) -> Self {
        Self {
            name: name.into(),
            description: description.into(),
            schema,
            function: Arc::new(f),
            _in: PhantomData,
            _out: PhantomData,
        }
    }

    /// Create a new typed tool with schema inferred from the input type `I`.
    pub fn new_inferred(name: impl Into<String>, description: impl Into<String>, f: F) -> Self
    where
        I: JsonSchema,
    {
        let schema = schemars::schema_for!(I);
        let schema_value = serde_json::to_value(schema.schema)
            .unwrap_or_else(|_| serde_json::json!({"type":"object"}));
        Self {
            name: name.into(),
            description: description.into(),
            schema: schema_value,
            function: Arc::new(f),
            _in: PhantomData,
            _out: PhantomData,
        }
    }

    /// Set a custom name for this tool.
    ///
    /// By default, tools use the name provided at construction.
    /// This method allows overriding that name.
    pub fn with_name(mut self, name: impl Into<String>) -> Self {
        self.name = name.into();
        self
    }

    /// Add a layer to this tool, returning a LayeredTool.
    ///
    /// This consumes the tool and returns a LayeredTool that can have
    /// additional layers added to it.
    pub fn layer(self, layer: Arc<dyn ErasedToolLayer>) -> LayeredTool {
        LayeredTool::new(Arc::new(self)).layer(layer)
    }
}

#[async_trait]
impl<I, O, F> Tool for TypedFunctionTool<I, O, F>
where
    I: serde::de::DeserializeOwned + Send + Sync + 'static,
    O: serde::Serialize + Send + Sync + 'static,
    F: Fn(I) -> crate::error::Result<O> + Send + Sync + 'static,
{
    fn name(&self) -> &str {
        &self.name
    }
    fn description(&self) -> &str {
        &self.description
    }
    fn parameters_schema(&self) -> Value {
        self.schema.clone()
    }

    async fn execute(&self, arguments: Value) -> Result<ToolResult> {
        let parsed: I = match serde_json::from_value(arguments) {
            Ok(v) => v,
            Err(e) => {
                return Ok(ToolResult::error(format!("invalid arguments: {}", e)));
            }
        };
        match (self.function)(parsed) {
            Ok(out) => match serde_json::to_value(out) {
                Ok(val) => Ok(ToolResult::success(val)),
                Err(e) => Ok(ToolResult::error(format!("serialization error: {}", e))),
            },
            Err(e) => Ok(ToolResult::error(e.to_string())),
        }
    }
}

/// A macro to simplify the creation of a [`FunctionTool`] from a simple function.
#[macro_export]
macro_rules! function_tool {
    ($name:expr, $description:expr, $func:expr) => {
        $crate::tool::FunctionTool::simple($name, $description, $func)
    };
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;

    #[test]
    fn test_tool_result_creation() {
        let result = ToolResult::success(serde_json::json!({"data": "test"}));
        assert!(!result.is_final);
        assert!(result.error.is_none());
        assert_eq!(result.output, serde_json::json!({"data": "test"}));

        let final_result = ToolResult::final_output(serde_json::json!("done"));
        assert!(final_result.is_final);
        assert!(final_result.error.is_none());

        let error_result = ToolResult::error("Something went wrong".to_string());
        assert!(!error_result.is_final);
        assert_eq!(error_result.error, Some("Something went wrong".to_string()));
    }

    #[test]
    fn test_function_tool_simple() {
        let tool = FunctionTool::simple("uppercase", "Converts text to uppercase", |s: String| {
            s.to_uppercase()
        });

        assert_eq!(tool.name(), "uppercase");
        assert_eq!(tool.description(), "Converts text to uppercase");

        let schema = tool.parameters_schema();
        assert!(schema.is_object());
        assert_eq!(schema["type"], "object");
    }

    #[tokio::test]
    async fn test_function_tool_execution() {
        let tool = FunctionTool::simple("reverse", "Reverses a string", |s: String| {
            s.chars().rev().collect()
        });

        let args = serde_json::json!({"input": "hello"});
        let result = tool.execute(args).await.unwrap();

        assert_eq!(result.output, Value::String("olleh".to_string()));
        assert!(!result.is_final);
        assert!(result.error.is_none());
    }

    #[test]
    fn test_function_tool_with_complex_schema() {
        let schema = serde_json::json!({
            "type": "object",
            "properties": {
                "city": {"type": "string", "description": "The city name"},
                "units": {"type": "string", "enum": ["celsius", "fahrenheit"], "description": "Temperature units"}
            },
            "required": ["city"]
        });

        let tool = FunctionTool::new(
            "get_weather".to_string(),
            "Get weather for a city".to_string(),
            schema.clone(),
            |args| {
                let city = args
                    .get("city")
                    .and_then(|v| v.as_str())
                    .unwrap_or("unknown");
                Ok(serde_json::json!({
                    "temperature": 22,
                    "city": city,
                    "condition": "sunny"
                }))
            },
        );

        assert_eq!(tool.parameters_schema(), schema);
    }

    #[tokio::test]
    async fn test_function_tool_error_handling() {
        let tool = FunctionTool::new(
            "failing_tool".to_string(),
            "A tool that fails".to_string(),
            serde_json::json!({}),
            |_| {
                Err(crate::error::AgentsError::ToolExecutionError {
                    message: "Intentional failure".to_string(),
                })
            },
        );

        let result = tool.execute(serde_json::json!({})).await.unwrap();
        assert!(result.error.is_some());
        assert!(result.error.unwrap().contains("Intentional failure"));
    }

    #[test]
    fn test_function_tool_macro() {
        let tool = function_tool!("echo", "Echoes the input", |s: String| format!(
            "Echo: {}",
            s
        ));

        assert_eq!(tool.name(), "echo");
        assert_eq!(tool.description(), "Echoes the input");
    }

    #[tokio::test]
    async fn test_typed_function_tool() {
        #[derive(Deserialize)]
        struct AddArgs {
            x: i32,
            y: i32,
        }
        #[derive(Serialize)]
        struct Sum {
            sum: i32,
        }

        let schema = serde_json::json!({
            "type":"object",
            "properties":{ "x": {"type":"integer"}, "y": {"type":"integer"} },
            "required":["x","y"]
        });
        let tool = TypedFunctionTool::new("add", "Adds two numbers", schema, |a: AddArgs| {
            Ok(Sum { sum: a.x + a.y })
        });
        let args = serde_json::json!({"x": 2, "y": 5});
        let result = tool.execute(args).await.unwrap();
        assert!(result.error.is_none());
        assert_eq!(result.output, serde_json::json!({"sum":7}));
    }

    #[tokio::test]
    async fn test_typed_function_tool_inferred_schema() {
        #[derive(Deserialize, JsonSchema)]
        struct Args {
            v: String,
        }
        #[derive(Serialize)]
        struct Out {
            len: usize,
        }
        let tool = TypedFunctionTool::<Args, Out, _>::new_inferred(
            "len",
            "Returns string length",
            |a: Args| Ok(Out { len: a.v.len() }),
        );
        let args = serde_json::json!({"v":"abc"});
        let res = tool.execute(args).await.unwrap();
        assert!(res.error.is_none());
        assert_eq!(res.output, serde_json::json!({"len":3}));
        let schema = tool.parameters_schema();
        assert!(schema.is_object());
    }

    #[tokio::test]
    async fn test_tool_args_and_output_macros_compile_and_run() {
        use crate::{tool_args, tool_output};
        #[tool_args]
        struct Args {
            v: String,
        }
        #[tool_output]
        struct Out {
            len: usize,
        }

        let tool = TypedFunctionTool::<Args, Out, _>::new_inferred(
            "len",
            "Returns string length",
            |a: Args| Ok(Out { len: a.v.len() }),
        );
        let args = serde_json::json!({"v":"abcd"});
        let res = tool.execute(args).await.unwrap();
        assert!(res.error.is_none());
        assert_eq!(res.output, serde_json::json!({"len":4}));
        let schema = tool.parameters_schema();
        assert!(schema.is_object());
    }
}
